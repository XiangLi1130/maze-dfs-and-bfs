package HW8;

import java.util.*;

/**
 * Contains the maze struture, which is just an array of <code>MazeCell</code>s.
 * Also contains the algorithms for generating and solving the maze.
 *
 */
public class Maze {

	private int rows, cols;
	private MazeCell maze[][];
	// the UI code is all in MazeViewer.java
	private MazeViewer viewer;
	// This is just for random number generation
	private Random generator;
	private MazeCell startCell;
	private MazeCell endCell;
	LinkedList<MazeCell> bfspath = new LinkedList<MazeCell>();

	/**
	 * Creates a maze that has the given number of rows and columns. Sets the
	 * neighbors of each cell.
	 * 
	 * @param rows
	 *            Number of rows in the maze.
	 * @param cols
	 *            Number of columns in the maze.
	 */
	public Maze(int rows, int cols) {
		this.rows = rows;
		this.cols = cols;
		generator = new Random();

		// Create the maze.
		maze = new MazeCell[rows][cols];
		for (int i = 0; i < rows; i++) {
			for (int j = 0; j < cols; j++) {
				maze[i][j] = new MazeCell();
			}
		}

		// Set the neighbors for each cell in the maze.
		for (int i = 0; i < rows; i++) {
			for (int j = 0; j < cols; j++) {
				MazeCell n, e, s, w;
				if (i == 0)
					n = null; // On north border of maze
				else
					n = maze[i - 1][j];

				if (i == rows - 1)
					s = null; // On south border of maze
				else
					s = maze[i + 1][j];

				if (j == 0)
					w = null; // On west border of maze
				else
					w = maze[i][j - 1];

				if (j == cols - 1)
					e = null; // On east border of maze
				else
					e = maze[i][j + 1];

				maze[i][j].setNeighbors(n, e, s, w);
			}
		}
	}

	/**
	 * Accessor that sets the <code>MazeViewer</code> variable for the maze.
	 * When the viewer is not set, no visualization takes place.
	 * 
	 * @param viewer
	 *            Visual display place for the maze.
	 */
	public void setViewer(MazeViewer viewer) {
		this.viewer = viewer;
	}

	/**
	 * Accessor that sets the start cell for the maze.
	 * 
	 * @param cell
	 *            Start cell for the maze.
	 */
	public void setStartCell(MazeCell cell) {
		startCell = cell;
	}

	/**
	 * Accessor that sets the end cell for the maze.
	 * 
	 * @param cell
	 *            End cell for the maze.
	 */
	public void setEndCell(MazeCell cell) {
		endCell = cell;
	}

	/**
	 * Accessor that returns the start cell for the maze.
	 * 
	 * @return Start cell for the maze.
	 */
	public MazeCell getStartCell() {
		return startCell;
	}

	/**
	 * Accessor that returns the end cell for the maze.
	 * 
	 * @return End cell for the maze.
	 */
	public MazeCell getEndCell() {
		return endCell;
	}

	/**
	 * Accessor that returns the number of rows in the maze.
	 * 
	 * @return The number of rows in the maze.
	 */
	public int getRows() {
		return rows;
	}

	/**
	 * Accessor that returns the number of columns in the maze.
	 * 
	 * @return The number of columns in the maze.
	 */
	public int getCols() {
		return cols;
	}

	/**
	 * Returns the cell in the maze at the given coordinates.
	 * 
	 * @param row
	 *            The row in the maze of the cell.
	 * @param col
	 *            The column in the maze of the cell.
	 * @return The cell at (<code>row</code>, <code>col</code>)
	 */
	public MazeCell getCell(int row, int col) {
		// TODO - correct this.
		return this.maze[row][col];
	}

	/**
	 * Tells the viewer to show the maze again, with any changes to cells
	 * updated. The current cell will be colored in the viewer. If the viewer is
	 * null, this method does nothing.
	 * 
	 * @param cell
	 *            Current cell, that the viewer will color.
	 */
	public synchronized void visualize(MazeCell cell) {
		// TODO - call the appropriate method from MazeViewer to visualize
		this.viewer.visualize(cell);
	}

	/**
	 * Generates the maze. The maze is generated by Kruskal's algorithm
	 */
	public synchronized void generateMaze() {
		makeKruskalMaze();
		// you can change the startCell and endCell values
		startCell = maze[0][0];
		endCell = maze[rows - 1][cols - 1];
	}

	/**
	 * Forms the maze via Kruskal's algorithm.
	 */
	public synchronized void makeKruskalMaze() {
		DisjointSet ds = new DisjointSet();
		ds.makeSet(this.maze);
		int num = 0;
		while (num < this.rows * this.cols - 1) {
			int i = this.generator.nextInt(rows);
			int j = this.generator.nextInt(cols);
			MazeCell current = this.getCell(i, j);
			MazeCell n = current.getRandomNeighbor();
			if (n != null) {
				MazeCell f1 = ds.find(current);
				MazeCell f2 = ds.find(n);
				if (f1 != f2) {
					ds.union(f1, f2);
					current.knockDownWall(n);
					num++;
				}
			}
		}
	}

	/**
	 * Solve maze. The input parameter is guaranteed to be one of "dfs", "bfs",
	 * or "random".
	 * 
	 * @param method
	 *            The method for solving the maze; one of "dfs" = depth first
	 *            search, "bfs" = breadth first search, "random" = random walk.
	 */
	public synchronized void solveMaze(String method) {
		if (method.equals("dfs")) {
			solveDFSMaze();
		} else if (method.equals("bfs")) {
			solveBFSMaze();
		} else if (method.equals("random")) {
			solveRandomMaze();
		}
	}

	/**
	 * Solves the maze by randomly choosing a neighboring cell to explore. This
	 * method has been written for you. Please note this method takes a very
	 * long time to complete.
	 */
	public synchronized void solveRandomMaze() {
		// Start the search at the start cell
		MazeCell current = startCell;

		// while we haven't reached the end of the maze
		while (current != endCell) {
			visualize(current); // show the progress visually (repaint)
			MazeCell neighbors[] = current.getNeighbors();
			int index = generator.nextInt(neighbors.length);
			current.examine();
			current = neighbors[index];
		}
		visualize(current);
	}

	/**
	 * Solves the maze by depth first search.
	 */
	public synchronized void solveDFSMaze() {
		MazeCell start = this.startCell;
		Stack<MazeCell> stack = new Stack<MazeCell>();
		stack.push(start);
		while (start != this.endCell) {
			start = stack.peek();
			if (start == this.endCell) {
				start.examine();
				visualize(start);
				break;
			}
			start.visit();
			visualize(start);
			int count = 0;
			for (MazeCell mc : start.getNeighbors()) {
				if (!mc.examined() && !mc.visited()) {
					stack.push(mc);
					count++;
				}
			}
			if (count == 0) { //no neighbor which is unvisited
				              //means the vertex is finished
				start.examine();
				visualize(start);
				stack.pop();
			}
		}
	}

	/**
	 * Solves the maze by breadth first search. starts at the start vertex and
	 * stops when bfs discovers the end vertex
	 */
	public synchronized void solveBFSMaze() {
		MazeCell start = this.startCell;
		Queue<MazeCell> queue = new LinkedList<MazeCell>();
		HashMap<MazeCell, MazeCell> directionMap = new HashMap<MazeCell, MazeCell>();
		queue.add(start);
		while (start != this.endCell) {
			start = queue.remove();
			start.visit();
			// start.examine();
			for (MazeCell mc : start.getNeighbors()) {
				if (!mc.visited()) {
					// if (!mc.examined()) {
					queue.add(mc);
					directionMap.put(mc, start);
				}
			}
			visualize(start);

		}
		MazeCell vertex = this.endCell;
		while (vertex != null) {
			this.bfspath.add(vertex);
			vertex = directionMap.get(vertex);
			if (vertex != null) {
				vertex.examine();// the gray vertices shows the path
			}
		}
		visualize(vertex);// the gray vertices shows the final path
	}

}
